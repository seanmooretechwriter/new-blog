---
title: My Top AI Tools for Coding in 2025
date: 2025-09-03
description: A comprehensive look at the best AI tools for coding, from chatbots like Gemini Pro 2.5 and Claude Opus to AI-enabled IDEs and CLI tools, with practical insights on managing expectations and maximizing productivity.
tags: posts
layout: post.njk
---

Over the last few years, I've used AI to write code. I've tried several different tools, from chatbots to AI enabled IDEs and CLIs.

One standout chatbot is Gemini with Gemini Pro 2.5. Claude chatbot with Claude Opus, and to a lesser degree Sonnet, is also quite effective. When I work with a chatbot to write code, the process is generally iterative and precise. This approach has proven effective. My first experiences were with the initial versions of ChatGPT. Over time, both my skills and the models themselves have improved in terms of getting the results I need.

In the beginning, I mostly experimented with chatbots using generic prompts and requests, such as "Build me a personal Vue website." I also had ChatGPT provide solutions to LeetCode DSA problems with prompts like "Provide a modern JavaScript solution for the two sum LeetCode problem."

My initial experiences with chatbots were somewhat segmented. I'd either ask questions and look for answers, or have the AI generate code. As I learned more about prompting and the AI's capabilities, the lines blurred between using AI as a language reference, Google, and Stack Overflow replacement versus sending prompts to generate functional code.

This evolution led to my current approach. It's like having a second brain, rubber duck, and pairing partner with extensive memory and access to all the information the model has consumed about various programming languages. While it's not perfect, I've found that managing expectations is key to getting value from these tools. Understanding their current capabilities helps avoid the frustration that many developers experience.

Setting realistic expectations is important when working with any tool, but it's especially crucial with AI. When you approach a specific task with an open mind and use a quality model, the results can be impressive. I converse with the model as if I'm having a discussion with another developer. As context windows continue to grow, these models can remember everything in our conversation and help organize thoughts effectively. The key is using AI as a tool to augment your thinking, not replace it.

Another approach I've been exploring is IDEs with AI capabilities. I've used both VS Code with Copilot and Cursor with various models. When I first started using AI for coding, I envisioned tools like these. They're particularly effective for granular work, functioning like a second brain and set of hands working alongside you. You can instruct the tool to modify your code, then review and accept changes similar to a pull request review. Rather than letting AI rewrite code at will, you drive the process and adjust instructions as you develop.

This approach has produced solid results. It maintains the familiar development workflow while adding automation and reducing typing. For developers who've been coding for decades and may have developed RSI like I have, saving keystrokes is invaluable. The resistance some developers show toward these productivity tools seems rooted in uncertainty about change rather than the tools' actual limitations.

I recently read an interesting comparison between our current moment with AI and coding to when compilers were first introduced. Historical records show that some developers initially resisted compilers too. Throughout my career, I've witnessed skilled developers resist various innovations: source control, unit testing, CSS, web services, XML, smartphones, and social media when they were new. While healthy skepticism is valuable, it's worth thoroughly experimenting with new technologies before dismissing them.

The third category is CLI tools. These typically take a different approach, making broader passes at generating substantial amounts of code. This method is rooted in project planning, design, and architecture. Essentially, a technical architect carefully thinks through the application and codebase, writes technical specifications, then uses AI to generate the implementation. While this approach shows promise, it's currently more prone to errors. The next year or two will likely bring significant improvements in this area, possibly representing the future of software development.

It's worth noting that we have limited visibility into what AI companies are developing behind the scenes. Their unreleased tools and technologies could significantly change the development landscape. While there's speculation about AI replacing developers, the currently available tools suggest we're not there yet. However, as AI matures and companies iterate on their products, the landscape will continue evolving.

As more people adopt AI tools, new practices, standards, and techniques for successfully using AI in development will emerge. The choice facing developers is whether to actively learn and adapt or wait to see what happens. My approach is to continue learning as much as possible about these tools and their effective use. In an industry that has always rewarded adaptability, staying current with AI capabilities seems like the most practical strategy for long term success.